<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cursed Calendar Timer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=MedievalSharp&display=swap" rel="stylesheet">
    <style>
        /* New custom font class for the timer */
        .font-ancient {
            font-family: 'MedievalSharp', cursive;
        }

        /* Main container for the dark, ruinous atmosphere */
        body {
            /* Set the new background image */
            background-image: url('slet.jpeg');
            background-size: cover; /* Ensure the image covers the whole page */
            background-position: center; /* Center the image */
            background-repeat: no-repeat; /* Do not repeat the image */
            background-color: #1a1a1a; /* Fallback color */
            overflow: hidden; /* Hide overflow to keep elements contained */
            position: relative;
            touch-action: none; /* Prevents scrolling on touch devices while dragging */
        }
        
        /* The main calendar container is now the interactive element */
        #calendar-container {
            cursor: pointer;
        }

        /* The main calendar image styling */
        #calendar-image {
            transition: transform 0.05s linear; /* Faster transition for smooth dragging */
            transform-origin: center;
        }
        
        /* Styling for the timer display in the center */
        #timer-display {
            color: #feeaa5; /* Lighter, brighter gold color */
            user-select: none; /* Prevent text selection */
            pointer-events: none; /* Make sure clicks go through to the container */
            /* Multi-layered shadow for a strong, glowing, golden effect */
            text-shadow:
                /* Inner dark shadow for depth and contrast */
                0px 2px 3px #1c1403,
                /* Bright golden glow */
                0 0 8px #ffc700,
                0 0 12px #ffc700,
                /* Wider, softer orange aura */
                0 0 25px #ff8c00,
                0 0 40px #ff8c00;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4 font-sans relative">
    <!-- Removed the old #temple-background div -->
    <div id="torchlight-overlay"></div>

    <main class="flex flex-col lg:flex-row items-center justify-center gap-8 z-10 w-full max-w-6xl">

        <!-- The Aztec Calendar is now the main control -->
        <div id="calendar-container" class="relative flex items-center justify-center w-full max-w-sm md:max-w-md lg:max-w-lg">
            <img id="calendar-image" 
                 src="https://defythegrid.com/wp-content/uploads/2024/07/dg_cop_az_5oz_rev_600x600_png.png" 
                 alt="Aztec Calendar" 
                 class="w-full h-auto"
                 onerror="this.onerror=null; this.src='https://placehold.co/500x500/3a362b/ffffff?text=Calendar+Not+Found';">
            
            <!-- Timer Display with new font class -->
            <div id="timer-display" class="absolute font-ancient text-6xl md:text-8xl">
                10:00
            </div>
        </div>

    </main>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Element References ---
            const timerDisplay = document.getElementById('timer-display');
            const calendarContainer = document.getElementById('calendar-container');
            const calendarImage = document.getElementById('calendar-image');

            // --- State Variables ---
            const TOTAL_TIME = 600; // 10 minutes in seconds
            let timeLeft = TOTAL_TIME;
            let timerInterval = null;
            let isPaused = true;
            let currentRotation = 0;
            const rotationPerSecond = 360 / TOTAL_TIME; 

            // --- Dragging / Rewind State ---
            let isDragging = false;
            let wasDragged = false; // Differentiates a drag from a click
            let lastAngle = 0;
            let center = { x: 0, y: 0 };

            // --- Audio Synthesis with Tone.js ---
            const stoneGrind = new Tone.NoiseSynth({
                noise: { type: 'brown' },
                envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 }
            }).toDestination();
            stoneGrind.volume.value = -10;

            const tribalDrum = new Tone.MembraneSynth({ pitchDecay: 0.02, octaves: 6, oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.5, sustain: 0.01, release: 0.4 } }).toDestination();
            tribalDrum.volume.value = -8;
            const drumPattern = new Tone.Sequence((time, note) => { tribalDrum.triggerAttackRelease(note, '8n', time); }, ['C2', ['C2', 'G1'], 'G1', ['C2', 'G1']], '2n').start(0);
            const eerieFlute = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.5, decay: 1, sustain: 0.2, release: 2 } }).toDestination();
            eerieFlute.volume.value = -20;
            const flutePattern = new Tone.Sequence((time, note) => { eerieFlute.triggerAttackRelease(note, '1n', time); }, [['E4', 'G4'], 'A4', ['C5', 'A4'], 'G4'], '1m').start('1m');
            const jungleAmbience = new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 4, decay: 2, sustain: 1, release: 5 } }).toDestination();
            jungleAmbience.volume.value = -35;
            const ambienceLoop = new Tone.Loop(time => { jungleAmbience.triggerAttackRelease('4m', time); }, '3m').start(0);
            
            const collapseSound = () => { 
                const rumble = new Tone.NoiseSynth({ noise: { type: 'brown', playbackRate: 0.5 }, envelope: { attack: 0.1, decay: 3, sustain: 0, release: 2 } }).toDestination();
                rumble.volume.value = -5;
                rumble.triggerAttackRelease('3s', Tone.now());
                const crash = new Tone.MetalSynth({ frequency: 100, envelope: { attack: 0.01, decay: 1.5, release: 1 }, harmonicity: 8.1, modulationIndex: 40, resonance: 2000, octaves: 2 }).toDestination();
                crash.volume.value = -10;
                crash.triggerAttack(Tone.now() + 0.2);
             };

            // --- Core Timer Functions ---
            function formatTime(seconds) {
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = seconds % 60;
                return `${String(minutes).padStart(2, '0')}:${String(Math.round(remainingSeconds)).padStart(2, '0')}`;
            }

            function updateDisplay() {
                timerDisplay.textContent = formatTime(timeLeft);
                currentRotation = (TOTAL_TIME - timeLeft) * rotationPerSecond;
                calendarImage.style.transform = `rotate(${currentRotation}deg)`;
            }

            function tick() {
                if (timeLeft > 0) {
                    timeLeft--;
                    updateDisplay();
                } else {
                    timeLeft = 0;
                    clearInterval(timerInterval);
                    timerInterval = null;
                    Tone.Transport.stop();
                    collapseSound();
                    updateDisplay();
                }
            }

            function startTimer() {
                if (isPaused && timeLeft > 0) {
                    isPaused = false;
                    Tone.start().then(() => { Tone.Transport.start(); }); 
                    timerInterval = setInterval(tick, 1000);
                }
            }

            function pauseTimer() {
                if (!isPaused) {
                    isPaused = true;
                    clearInterval(timerInterval);
                    timerInterval = null;
                    Tone.Transport.pause();
                }
            }
            
            // --- Rewind Gesture Functions ---
            function updateCenter() {
                const rect = calendarContainer.getBoundingClientRect();
                center.x = rect.left + rect.width / 2;
                center.y = rect.top + rect.height / 2;
            }
            
            function handleDragStart(e) {
                e.preventDefault();
                updateCenter();
                isDragging = true;
                wasDragged = false;
                pauseTimer(); // Always pause when starting a drag
                
                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;
                
                lastAngle = Math.atan2(clientY - center.y, clientX - center.x);
            }

            function handleDragMove(e) {
                if (!isDragging) return;
                e.preventDefault();
                wasDragged = true;

                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;

                const currentAngle = Math.atan2(clientY - center.y, clientX - center.x);
                let angleDelta = currentAngle - lastAngle;

                // Handle angle wrapping (crossing the -180/180 degree boundary)
                if (angleDelta > Math.PI) angleDelta -= 2 * Math.PI;
                if (angleDelta < -Math.PI) angleDelta += 2 * Math.PI;

                const timeChange = (angleDelta / (2 * Math.PI)) * TOTAL_TIME;
                
                timeLeft -= timeChange;

                // Clamp timeLeft between 0 and TOTAL_TIME
                timeLeft = Math.max(0, Math.min(TOTAL_TIME, timeLeft));

                updateDisplay();
                lastAngle = currentAngle;
            }

            function handleDragEnd(e) {
                if (!isDragging) return;
                isDragging = false;
                
                // If it wasn't a drag, treat it as a click to toggle the timer
                if (!wasDragged) {
                    stoneGrind.triggerAttackRelease(0.1);
                    if (isPaused) {
                        startTimer();
                    } else {
                        // This else will be hit because we paused on drag start
                        startTimer();
                    }
                } else {
                    // If it was a drag, we just leave the timer paused at the new time
                     if(timeLeft > 0) isPaused = true;
                }
            }


            // --- Event Listeners ---
            calendarContainer.addEventListener('mousedown', handleDragStart);
            document.addEventListener('mousemove', handleDragMove);
            document.addEventListener('mouseup', handleDragEnd);

            calendarContainer.addEventListener('touchstart', handleDragStart, { passive: false });
            document.addEventListener('touchmove', handleDragMove, { passive: false });
            document.addEventListener('touchend', handleDragEnd);

            window.addEventListener('resize', updateCenter);


            // --- Initial Setup ---
            updateDisplay(); 
        });
    </script>
</body>
</html>
